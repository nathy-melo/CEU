<?php

/**
 * Gerador de C√≥digos Seguros para Organizadores
 * Sistema melhorado com c√≥digos verdadeiramente aleat√≥rios
 */

class GeradorCodigoSeguro
{

    /**
     * Caracteres permitidos para c√≥digos (sem confus√µes visuais)
     * Removido: 0, O, I, 1, l para evitar confus√£o
     */
    private static $caracteres = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';

    /**
     * Gera um c√≥digo verdadeiramente aleat√≥rio e √∫nico
     */
    public static function gerarCodigo($conexao, $tentativas = 10)
    {
        for ($i = 0; $i < $tentativas; $i++) {
            $codigo = self::gerarCodigoAleatorio();

            // Verifica se j√° existe no banco
            if (!self::codigoJaExiste($conexao, $codigo)) {
                return $codigo;
            }
        }

        // Se ap√≥s 10 tentativas n√£o conseguiu gerar √∫nico, for√ßa com timestamp
        return self::gerarCodigoComTimestamp();
    }

    /**
     * Gera c√≥digo totalmente aleat√≥rio de 8 caracteres
     */
    private static function gerarCodigoAleatorio()
    {
        $codigo = '';
        $maxIndex = strlen(self::$caracteres) - 1;

        // Gera 8 caracteres aleat√≥rios
        for ($i = 0; $i < 8; $i++) {
            $codigo .= self::$caracteres[random_int(0, $maxIndex)];
        }

        return $codigo;
    }

    /**
     * Gera c√≥digo com timestamp para garantir unicidade
     */
    private static function gerarCodigoComTimestamp()
    {
        $timestamp = substr(str_replace('.', '', microtime(true)), -6);
        $random = '';
        $maxIndex = strlen(self::$caracteres) - 1;

        // 2 caracteres aleat√≥rios + 6 d√≠gitos do timestamp convertidos
        for ($i = 0; $i < 2; $i++) {
            $random .= self::$caracteres[random_int(0, $maxIndex)];
        }

        // Converte timestamp para caracteres do nosso conjunto
        $timestampConverted = '';
        $timestampNum = intval($timestamp);
        $base = strlen(self::$caracteres);

        while ($timestampNum > 0) {
            $timestampConverted = self::$caracteres[$timestampNum % $base] . $timestampConverted;
            $timestampNum = intval($timestampNum / $base);
        }

        return $random . str_pad($timestampConverted, 6, self::$caracteres[0], STR_PAD_LEFT);
    }

    /**
     * Verifica se c√≥digo j√° existe no banco
     */
    private static function codigoJaExiste($conexao, $codigo)
    {
        $sql = "SELECT id FROM codigos_organizador WHERE codigo = ?";
        $stmt = mysqli_prepare($conexao, $sql);
        mysqli_stmt_bind_param($stmt, "s", $codigo);
        mysqli_stmt_execute($stmt);
        $result = mysqli_stmt_get_result($stmt);

        return mysqli_num_rows($result) > 0;
    }

    /**
     * Gera m√∫ltiplos c√≥digos √∫nicos
     */
    public static function gerarMultiplosCodigos($conexao, $quantidade = 5)
    {
        $codigos = [];

        for ($i = 0; $i < $quantidade; $i++) {
            $codigo = self::gerarCodigo($conexao);
            $codigos[] = $codigo;
        }

        return $codigos;
    }

    /**
     * Valida formato do c√≥digo
     */
    public static function validarFormato($codigo)
    {
        // Debug
        error_log("GeradorCodigoSeguro::validarFormato - Validando c√≥digo: '$codigo' (length: " . strlen($codigo) . ")");

        // Deve ter exatamente 8 caracteres
        if (strlen($codigo) !== 8) {
            error_log("GeradorCodigoSeguro::validarFormato - FALHOU: Tamanho incorreto");
            return false;
        }

        // Todos os caracteres devem estar no conjunto permitido
        for ($i = 0; $i < strlen($codigo); $i++) {
            if (strpos(self::$caracteres, $codigo[$i]) === false) {
                error_log("GeradorCodigoSeguro::validarFormato - FALHOU: Caractere inv√°lido '" . $codigo[$i] . "' na posi√ß√£o $i");
                return false;
            }
        }

        error_log("GeradorCodigoSeguro::validarFormato - SUCESSO: C√≥digo v√°lido");
        return true;
    }

    /**
     * Gera c√≥digo para migra√ß√£o dos c√≥digos antigos
     */
    public static function migrarCodigosExistentes($conexao)
    {
        echo "üîÑ Iniciando migra√ß√£o de c√≥digos antigos...\n";

        // Busca c√≥digos com padr√£o antigo (ORG + n√∫meros)
        $sql = "SELECT id, codigo FROM codigos_organizador WHERE codigo LIKE 'ORG%'";
        $result = mysqli_query($conexao, $sql);

        $migrados = 0;
        while ($row = mysqli_fetch_assoc($result)) {
            $novodCodigo = self::gerarCodigo($conexao);

            $sqlUpdate = "UPDATE codigos_organizador SET codigo = ? WHERE id = ?";
            $stmtUpdate = mysqli_prepare($conexao, $sqlUpdate);
            mysqli_stmt_bind_param($stmtUpdate, "si", $novodCodigo, $row['id']);

            if (mysqli_stmt_execute($stmtUpdate)) {
                echo "‚úÖ Migrado: {$row['codigo']} ‚Üí $novodCodigo\n";
                $migrados++;
            } else {
                echo "‚ùå Erro ao migrar: {$row['codigo']}\n";
            }
        }

        echo "üéâ Migra√ß√£o conclu√≠da! $migrados c√≥digos atualizados.\n";
        return $migrados;
    }
}
